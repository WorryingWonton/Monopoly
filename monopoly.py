import monopoly_cl_interface
import random
from functools import reduce
import cards
import board
from itertools import cycle

"""
6 November, 2018
Version 2 Goals:
    -Version 2 will allow the Active Player to perform multiple actions per turn
        -Players can perform as many actions as they'd like, so long as their state permits those actions to be performed
            -The Option List will regenerate each time the Player chooses an Option
        -Options presented to the Active Player are generated by Tile.list_options()
            -Tile.list_options() reads game state, and returns a list of Option objects the Active Player can choose from
        -Tile.tile_actions() is called ONLY when a Player lands on a Tile.
            -Tile.tile_actions() is the same for all Tiles, it does two things:
                1. Call Tile.perform_automatic_actions()
                    -Reads state, alters state IAW rules for that Tile, returns None
                2. Return Tile.list_options()
    -Version 2 will optionally enable auctioning a property the Active Player lands on, if they choose not to buy it
    -Version 2 will have the option for there to be a finite number of structures
        -At startup, if the finite option is selected, a user can enter how many house and hotel Structures they'd like the game to possess
"""

class Monopoly:

    def __init__(self, interface=None):
        self.players = []
        self.all_players = []
        self.board = board.Board().board
        self.chance_deck = cards.ChanceDeck()
        self.community_deck = cards.CommunityChest()
        self.active_player = None
        self.turns = 0
        self.bank = Bank(game=self)
        self.dice_roll = None
        if not interface:
            self.interface = monopoly_cl_interface.CLInterface(game=self)
        else:
            self.interface = interface

    def add_player(self, name):
        self.all_players.append(Player(name, game=self))

    def remove_player(self, player):
        player.in_game = False
        if player != self.active_player:
            self.generate_in_game_players()

    def generate_in_game_players(self):
        self.players = [player for player in self.all_players if player.in_game]

    def set_active_player(self):
        if not self.active_player:
            self.active_player = self.all_players[0]
        else:
            player_iterator = cycle(self.players)
            while next(player_iterator) != self.active_player:
                pass
            self.active_player = next(player_iterator)
        self.generate_in_game_players()

    def roll_dice(self):
        return (random.randint(1, 6), random.randint(1, 6))

    def run_turn(self):
        self.dice_roll = self.roll_dice()
        if not self.active_player.jailed:
            self.active_player.advance_position(amount=self.dice_roll[0] + self.dice_roll[1])
        print(f'\n---Pre Automatic Actions---{self.active_player.liquid_holdings}: --- {self.turns} --- {self.active_player.name} --- Pos: {self.active_player.position} ({self.board[self.active_player.position]}) --- {self.dice_roll} ---{[x.property.name for x in self.active_player.property_holdings]}')
        self.board[self.active_player.position].perform_auto_actions(game=self)
        print(f'\n---Post Automatic Actions---{self.active_player.liquid_holdings}: --- {self.turns} --- {self.active_player.name} --- Pos: {self.active_player.position} ({self.board[self.active_player.position]}) --- {self.dice_roll} ---{[x.property.name for x in self.active_player.property_holdings]}')
        option_list = []
        option_list += self.board[self.active_player.position].list_options(game=self)
        option_list += self.board[self.active_player.position].find_properties_of_other_players(game=self)
        for tile in [tile for tile in self.active_player.property_holdings if tile.position != self.active_player.position]:
            option_list += tile.list_options(game=self)
        option_list += self.active_player.player_actions()
        if len(option_list) > 0:
            active_player_decision = self.interface.get_decision(option_list)
            self.execute_player_decision(active_player_decision)
        return self.check_for_doubles()

    def execute_player_decision(self, active_player_decision):
        if active_player_decision:
            active_player_decision.action(self)

    def run_game(self):
        doubles = False
        self.generate_in_game_players()
        while len(self.players) > 1:
            if doubles:
                self.active_player.consecutive_turns += 1
                if self.active_player.consecutive_turns == 3:
                    self.active_player.consecutive_turns = 0
                    self.active_player.go_directly_to_jail()
                    self.set_active_player()
            else:
                self.set_active_player()
                self.active_player.consecutive_turns = 0
            self.advance_turn()
            doubles = self.run_turn()
        return self.players[0]

    def advance_turn(self):
        self.turns += 1

    def run_bankruptcy_process(self, creditor, debtor):
        #Perhaps unnecessary check to make sure the creditor is not being passed on debt
        if debtor.liquid_holdings >= 0:
            creditor.liquid_holdings += debtor.liquid_holdings
        for tile in debtor.property_holdings:
            if tile.property.mortgaged:
                creditor.liquid_holdings -= 0.1 * tile.property.mortgage_price
            for structure in tile.property.existing_structures:
                creditor.liquid_holdings += 0.5 * structure.price
                #Remove all structures after sale to bank
            tile.property.existing_structures = []
            creditor.property_holdings.append(tile)
        self.remove_player(debtor)
        if creditor == self.bank:
            self.run_bank_auction()

    def run_bank_auction(self):
        for tile in self.bank.property_holdings:
            winning_bid = self.interface.run_auction(item=tile.property, seller=self.bank)
            if winning_bid:
                tile.complete_transaction(buyer=winning_bid[0], seller=self.bank, amount=winning_bid[1])
        for card in self.bank.hand:
            winning_bid = self.interface.run_auction(item=card, seller=self.bank)
            if winning_bid:
                card.complete_transaction(buyer=winning_bid[0], seller=self.bank, amount=winning_bid[1], game=self)
        self.bank.property_holdings = []
        self.bank.hand = []

    def check_for_doubles(self):
        return self.dice_roll[0] == self.dice_roll[1]

class Option:
    def __init__(self, option_name, item_name, action):
        self.option_name = option_name
        self.item_name = item_name
        self.action = action
        self.item = None

class Bank:
    def __init__(self, game):
        self.name = 'the Bank'
        self.game = game
        self.property_holdings = []
        self.liquid_holdings = 0
        self.hand = []

class Player:

    def __init__(self, name, game):
        self.name = name
        self.position = 0
        self.liquid_holdings = 1500
        self.consecutive_turns = 0
        self.property_holdings = []
        self.jailed_turns = 0
        self.jailed = False
        self.hand = []
        self.game = game
        self.dealt_card = None
        self.in_game = True

    def player_actions(self):
        return self.generate_card_options()

    def find_gross_worth(self):
        gross_worth = self.liquid_holdings
        for tile in self.property_holdings:
            if tile.property.mortgaged:
                gross_worth += tile.property.mortgage_price
            else:
                gross_worth += tile.property.price
            if len(tile.property.existing_structures) > 0:
                for structure in tile.property.existing_structures:
                  gross_worth += structure.price/2
        return gross_worth

    def compute_advancement_amount(self, target_position):
        if target_position < self.position:
            amount = 40 - self.position + target_position
        else:
            amount = target_position - self.position
        return amount

    def advance_position(self, amount):
        if self.position + amount < 0:
            self.position += 40
            if not self.jailed:
                self.pass_go()
        self.position = (self.position + amount) % 40

    def go_directly_to_jail(self):
        self.position = 10
        self.jailed = True

    def generate_card_options(self):
        card_options = []
        for card in self.hand:
            card_options.append(Option(item_name=card.name, action=card.start_direct_sale_process, option_name=f'Sell {card.name}'))
        return card_options + self.list_cards_of_other_players()

    def list_cards_of_other_players(self):
        return [Option(option_name=f'Buy {card.name} from {card.find_owner(game=self.game).name}', item_name=card.name, action=card.start_direct_buy_process) for card in reduce(lambda card, next_card: card + next_card, [player.hand for player in list(filter(lambda player: player != self.game.active_player and len(player.hand) > 0, self.game.players))], [])]

    def pass_go(self):
        self.liquid_holdings += 200

if __name__ == '__main__':
    game_instance = Monopoly()
    game_instance.interface.add_players()
    game_instance.run_game()